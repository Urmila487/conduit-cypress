"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = require("fs");

var _events = _interopRequireDefault(require("events"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _network = _interopRequireDefault(require("./network"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

// Used by some methods to impose a strict maximum timeout, such as .goto and .snapshot
const PAGE_TIMEOUT = 30000;

var _browser = new WeakMap();

var _sessionId = new WeakMap();

var _targetId = new WeakMap();

var _frameId = new WeakMap();

var _contextId = new WeakMap();

var _callbacks = new WeakMap();

var _lifecycle = new WeakMap();

class Page extends _events.default {
  constructor(browser, {
    params
  }) {
    super();

    _browser.set(this, {
      writable: true,
      value: null
    });

    _sessionId.set(this, {
      writable: true,
      value: null
    });

    _targetId.set(this, {
      writable: true,
      value: null
    });

    _frameId.set(this, {
      writable: true,
      value: null
    });

    _contextId.set(this, {
      writable: true,
      value: null
    });

    _callbacks.set(this, {
      writable: true,
      value: new Map()
    });

    _lifecycle.set(this, {
      writable: true,
      value: new Set()
    });

    _defineProperty(this, "closedReason", null);

    _defineProperty(this, "log", (0, _logger.default)('core:page'));

    _defineProperty(this, "_handleLifecycleEvent", event => {
      if (_classPrivateFieldGet(this, _frameId) === event.frameId) {
        if (event.name === 'init') _classPrivateFieldGet(this, _lifecycle).clear();

        _classPrivateFieldGet(this, _lifecycle).add(event.name);
      }
    });

    _defineProperty(this, "_handleExecutionContextCreated", event => {
      if (_classPrivateFieldGet(this, _frameId) === event.context.auxData.frameId) {
        _classPrivateFieldSet(this, _contextId, event.context.id);
      }
    });

    _defineProperty(this, "_handleExecutionContextDestroyed", event => {
      /* istanbul ignore next: context cleared is usually called first */
      if (_classPrivateFieldGet(this, _contextId) === event.executionContextId) {
        _classPrivateFieldSet(this, _contextId, null);
      }
    });

    _defineProperty(this, "_handleExecutionContextsCleared", () => {
      _classPrivateFieldSet(this, _contextId, null);
    });

    _defineProperty(this, "_handleTargetCrashed", () => {
      this.closedReason = 'Page crashed!';
      /* istanbul ignore next: racey with browser close */

      this.close().catch(error => this.log.debug(error));
    });

    _classPrivateFieldSet(this, _browser, browser);

    _classPrivateFieldSet(this, _sessionId, params.sessionId);

    _classPrivateFieldSet(this, _targetId, params.targetInfo.targetId);

    this.network = new _network.default(this);
    this.on('Page.lifecycleEvent', this._handleLifecycleEvent);
    this.on('Runtime.executionContextCreated', this._handleExecutionContextCreated);
    this.on('Runtime.executionContextDestroyed', this._handleExecutionContextDestroyed);
    this.on('Runtime.executionContextsCleared', this._handleExecutionContextsCleared);
    this.on('Inspector.targetCrashed', this._handleTargetCrashed);
  } // initial page options asynchronously


  async init({
    cacheDisabled = true,
    enableJavaScript = true,
    requestHeaders = {},
    networkIdleTimeout,
    authorization,
    userAgent,
    intercept,
    height,
    width,
    meta
  } = {}) {
    this.log.debug('Initialize page', meta);
    this.network.timeout = networkIdleTimeout;
    this.network.authorization = authorization;
    this.meta = meta;
    let [, {
      frameTree
    }, version] = await Promise.all([this.send('Page.enable'), this.send('Page.getFrameTree'), this.send('Browser.getVersion')]);

    _classPrivateFieldSet(this, _frameId, frameTree.frame.id); // by default, emulate a non-headless browser


    userAgent || (userAgent = version.userAgent.replace('Headless', ''));
    await Promise.all([this.send('Runtime.enable'), this.send('Page.setLifecycleEventsEnabled', {
      enabled: true
    }), this.send('Network.setCacheDisabled', {
      cacheDisabled
    }), this.send('Network.setExtraHTTPHeaders', {
      headers: requestHeaders
    }), this.send('Network.setUserAgentOverride', {
      userAgent
    }), this.send('Security.setIgnoreCertificateErrors', {
      ignore: true
    }), this.send('Emulation.setScriptExecutionDisabled', {
      value: !enableJavaScript
    }), this.resize({
      width,
      height
    })]);

    if (intercept) {
      await this.network.intercept(intercept);
    }

    return this;
  } // Close the target page if not already closed


  async close() {
    if (!_classPrivateFieldGet(this, _browser)) return;
    await _classPrivateFieldGet(this, _browser).send('Target.closeTarget', {
      targetId: _classPrivateFieldGet(this, _targetId)
    }).catch(error => {
      /* istanbul ignore next: race condition */
      this.log.debug(error, this.meta);
    });
  }

  async resize({
    deviceScaleFactor = 1,
    mobile = false,
    height = 1024,
    width = 1280
  }) {
    this.log.debug(`Resize page to ${width}x${height}`);
    await this.send('Emulation.setDeviceMetricsOverride', {
      deviceScaleFactor,
      mobile,
      height,
      width
    });
  } // Go to a URL and wait for navigation to occur


  async goto(url, {
    waitUntil = 'load'
  } = {}) {
    let handleNavigate = event => {
      /* istanbul ignore else: sanity check */
      if (_classPrivateFieldGet(this, _frameId) === event.frame.id) handleNavigate.done = true;
    }; // set cookies before navigation so we can default the domain to this hostname


    if (_classPrivateFieldGet(this, _browser).cookies.length) {
      let defaultDomain = (0, _utils.hostname)(url);
      await this.send('Network.setCookies', {
        // spread is used to make a shallow copy of the cookie
        cookies: _classPrivateFieldGet(this, _browser).cookies.map(({ ...cookie
        }) => {
          if (!cookie.url) cookie.domain || (cookie.domain = defaultDomain);
          return cookie;
        })
      });
    }

    try {
      this.once('Page.frameNavigated', handleNavigate);
      this.log.debug(`Navigate to: ${url}`, this.meta); // trigger navigation and handle error responses

      let navigate = this.send('Page.navigate', {
        url
      }).then(({
        errorText
      }) => {
        if (errorText) throw new Error(errorText);
      }); // wait until navigation was handled and the correct lifecycle happened

      await Promise.all([navigate, (0, _utils.waitFor)(() => {
        if (this.closedReason) throw new Error(this.closedReason);
        return handleNavigate.done && _classPrivateFieldGet(this, _lifecycle).has(waitUntil);
      }, PAGE_TIMEOUT)]);
    } catch (error) {
      this.off('Page.frameNavigated', handleNavigate);
      throw Object.assign(error, {
        message: `Navigation failed: ${error.message}`
      });
    }

    this.log.debug('Page navigated', this.meta);
  } // Evaluate JS functions within the page's execution context


  async eval(fn, ...args) {
    let fnbody = fn.toString(); // we might have a function shorthand if this fails

    /* eslint-disable-next-line no-new, no-new-func */

    try {
      new Function(`(${fnbody})`);
    } catch (error) {
      fnbody = fnbody.startsWith('async ') ? fnbody.replace(/^async/, 'async function') : `function ${fnbody}`;
      /* eslint-disable-next-line no-new, no-new-func */

      try {
        new Function(`(${fnbody})`);
      } catch (error) {
        throw new Error('The provided function is not serializable');
      }
    } // wrap the function body with percy helpers


    fnbody = 'function withPercyHelpers() {' + (`return (${fnbody})({` + `waitFor: ${_utils.waitFor}` + '}, ...arguments)') + '}'; // send the call function command

    let {
      result,
      exceptionDetails
    } = await this.send('Runtime.callFunctionOn', {
      functionDeclaration: fnbody,
      arguments: args.map(value => ({
        value
      })),
      executionContextId: _classPrivateFieldGet(this, _contextId),
      returnByValue: true,
      awaitPromise: true,
      userGesture: true
    });

    if (exceptionDetails) {
      throw exceptionDetails.exception.description;
    } else {
      return result.value;
    }
  }

  async snapshot({
    name,
    waitForTimeout,
    waitForSelector,
    execute,
    ...options
  }) {
    // wait for any specified timeout
    if (waitForTimeout) {
      this.log.debug(`Wait for ${waitForTimeout}ms timeout`, this.meta);
      await new Promise(resolve => setTimeout(resolve, waitForTimeout));
    } // wait for any specified selector


    if (waitForSelector) {
      this.log.debug(`Wait for selector: ${waitForSelector}`, this.meta);
      /* istanbul ignore next: no instrumenting injected code */

      await this.eval(function waitForSelector({
        waitFor
      }, selector, timeout) {
        return waitFor(() => !!document.querySelector(selector), timeout).catch(() => Promise.reject(new Error(`Failed to find "${selector}"`)));
      }, waitForSelector, PAGE_TIMEOUT);
    } // execute any javascript


    if (execute) {
      this.log.debug('Execute JavaScript', { ...this.meta,
        execute
      }); // accept function bodies as strings

      if (typeof execute === 'string') execute = `async execute({ waitFor }) {\n${execute}\n}`; // execute the provided function

      await this.eval(execute);
    } // wait for any final network activity before capturing the dom snapshot


    await this.network.idle(); // inject @percy/dom for serialization by evaluating the file contents which adds a global
    // PercyDOM object that we can later check against

    /* istanbul ignore next: no instrumenting injected code */

    if (await this.eval(() => !window.PercyDOM)) {
      this.log.debug('Inject @percy/dom', this.meta);
      let script = await _fs.promises.readFile(require.resolve('@percy/dom'), 'utf-8');
      await this.eval(new Function(script));
      /* eslint-disable-line no-new-func */
    } // serialize and capture a DOM snapshot


    this.log.debug('Serialize DOM', this.meta);
    /* istanbul ignore next: no instrumenting injected code */

    return await this.eval((_, options) => ({
      /* eslint-disable-next-line no-undef */
      dom: PercyDOM.serialize(options),
      url: document.URL
    }), options);
  }

  async send(method, params) {
    let error = new Error();
    /* istanbul ignore next: race condition paranoia */

    if (this.closedReason) {
      return Promise.reject(Object.assign(error, {
        message: `Protocol error (${method}): ${this.closedReason}`
      }));
    } // send a raw message to the browser so we can provide a sessionId


    let id = await _classPrivateFieldGet(this, _browser).send({
      sessionId: _classPrivateFieldGet(this, _sessionId),
      method,
      params
    }); // return a promise that will resolve or reject when a response is received

    return new Promise((resolve, reject) => {
      _classPrivateFieldGet(this, _callbacks).set(id, {
        error,
        resolve,
        reject,
        method
      });
    });
  }

  _handleMessage(data) {
    if (data.id && _classPrivateFieldGet(this, _callbacks).has(data.id)) {
      // resolve or reject a pending promise created with #send()
      let callback = _classPrivateFieldGet(this, _callbacks).get(data.id);

      _classPrivateFieldGet(this, _callbacks).delete(data.id);

      if (data.error) {
        callback.reject(Object.assign(callback.error, {
          message: `Protocol error (${callback.method}): ${data.error.message}` + (
          /* istanbul ignore next: doesn't always exist so don't print undefined */
          'data' in data.error ? `: ${data.error.data}` : '')
        }));
      } else {
        callback.resolve(data.result);
      }
    } else {
      // emit the message as an event
      this.emit(data.method, data.params);
    }
  }

  _handleClose() {
    this.log.debug('Page closing', this.meta);
    this.closedReason || (this.closedReason = 'Page closed.'); // reject any pending callbacks

    for (let callback of _classPrivateFieldGet(this, _callbacks).values()) {
      callback.reject(Object.assign(callback.error, {
        message: `Protocol error (${callback.method}): ${this.closedReason}`
      }));
    }

    _classPrivateFieldGet(this, _callbacks).clear();

    _classPrivateFieldSet(this, _browser, null);
  }

}

exports.default = Page;