"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = _interopRequireDefault(require("@percy/logger"));

var _utils = require("./utils");

var _discovery = require("./discovery");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _pending = new WeakMap();

var _requests = new WeakMap();

var _intercepts = new WeakMap();

var _authentications = new WeakMap();

// The Interceptor class creates common handlers for dealing with intercepting asset requests
// for a given page using various devtools protocol events and commands.
class Network {
  constructor(page) {
    _pending.set(this, {
      writable: true,
      value: new Map()
    });

    _requests.set(this, {
      writable: true,
      value: new Map()
    });

    _intercepts.set(this, {
      writable: true,
      value: new Map()
    });

    _authentications.set(this, {
      writable: true,
      value: new Set()
    });

    _defineProperty(this, "log", (0, _logger.default)('core:network'));

    _defineProperty(this, "_handleAuthRequired", async event => {
      var _this$authorization;

      let {
        username,
        password
      } = (_this$authorization = this.authorization) !== null && _this$authorization !== void 0 ? _this$authorization : {};
      let {
        requestId
      } = event;
      let response = 'Default';

      if (_classPrivateFieldGet(this, _authentications).has(requestId)) {
        response = 'CancelAuth';
      } else if (username || password) {
        response = 'ProvideCredentials';

        _classPrivateFieldGet(this, _authentications).add(requestId);
      }

      await this.page.send('Fetch.continueWithAuth', {
        requestId: event.requestId,
        authChallengeResponse: {
          response,
          username,
          password
        }
      });
    });

    _defineProperty(this, "_handleRequestPaused", event => {
      let {
        networkId,
        requestId
      } = event;

      if (_classPrivateFieldGet(this, _pending).has(networkId)) {
        let pending = _classPrivateFieldGet(this, _pending).get(networkId);

        this._handleRequest(pending, requestId);

        _classPrivateFieldGet(this, _pending).delete(networkId);
      } else {
        _classPrivateFieldGet(this, _intercepts).set(networkId, requestId);
      }
    });

    _defineProperty(this, "_handleRequestWillBeSent", event => {
      let {
        requestId,
        request
      } = event; // do not handle data urls

      if (!request.url.startsWith('data:')) {
        if (_classPrivateFieldGet(this, _intercepts).has(requestId)) {
          let interceptId = _classPrivateFieldGet(this, _intercepts).get(requestId);

          this._handleRequest(event, interceptId);

          _classPrivateFieldGet(this, _intercepts).delete(requestId);
        } else if (this._intercept) {
          _classPrivateFieldGet(this, _pending).set(requestId, event);
        } else {
          this._handleRequest(event);
        }
      }
    });

    _defineProperty(this, "_handleRequest", async (event, interceptId) => {
      let {
        requestId,
        request
      } = event;
      let redirectChain = []; // if handling a redirected request, associate the response and add to its redirect chain

      if (event.redirectResponse && _classPrivateFieldGet(this, _requests).has(requestId)) {
        let req = _classPrivateFieldGet(this, _requests).get(requestId);

        req.response = event.redirectResponse;
        redirectChain = [...req.redirectChain, req]; // clean up auth redirects

        _classPrivateFieldGet(this, _authentications).delete(interceptId);
      }

      request.interceptId = interceptId;
      request.redirectChain = redirectChain;

      _classPrivateFieldGet(this, _requests).set(requestId, request);

      if (this._intercept) {
        await this.onrequest({ ...request,
          // call to continue the request as-is
          continue: () => this.page.send('Fetch.continueRequest', {
            requestId: interceptId
          }),
          // call to respond with a specific status, content, and headers
          respond: ({
            status,
            content,
            headers
          }) => this.page.send('Fetch.fulfillRequest', {
            requestId: interceptId,
            responseCode: status || 200,
            body: Buffer.from(content).toString('base64'),
            responseHeaders: Object.entries(headers || {}).map(([name, value]) => {
              return {
                name: name.toLowerCase(),
                value: String(value)
              };
            })
          }),
          // call to fail or abort the request
          abort: error => this.page.send('Fetch.failRequest', {
            requestId: interceptId,
            // istanbul note: this check used to be necessary and might be again in the future if we
            // ever need to abort a request due to reasons other than failures
            errorReason: error ? 'Failed' :
            /* istanbul ignore next */
            'Aborted'
          })
        });
      }
    });

    _defineProperty(this, "_handleResponseReceived", event => {
      let {
        requestId,
        response
      } = event;

      let request = _classPrivateFieldGet(this, _requests).get(requestId);
      /* istanbul ignore next: race condition paranioa */


      if (!request) return;
      request.response = response;

      request.response.buffer = async () => {
        let {
          body,
          base64Encoded
        } = await this.page.send('Network.getResponseBody', {
          requestId
        });
        return Buffer.from(body, base64Encoded ? 'base64' : 'utf8');
      };
    });

    _defineProperty(this, "_handleEventSourceMessageReceived", event => {
      let {
        requestId
      } = event;

      let request = _classPrivateFieldGet(this, _requests).get(requestId);
      /* istanbul ignore next: race condition paranioa */


      if (!request) return;

      _classPrivateFieldGet(this, _requests).delete(requestId);

      _classPrivateFieldGet(this, _authentications).delete(request.interceptId);
    });

    _defineProperty(this, "_handleLoadingFinished", async event => {
      let {
        requestId
      } = event;

      let request = _classPrivateFieldGet(this, _requests).get(requestId);
      /* istanbul ignore next: race condition paranioa */


      if (!request) return;

      if (this._intercept) {
        await this.onrequestfinished(request);
      }

      _classPrivateFieldGet(this, _requests).delete(requestId);

      _classPrivateFieldGet(this, _authentications).delete(request.interceptId);
    });

    _defineProperty(this, "_handleLoadingFailed", async event => {
      let {
        requestId,
        errorText
      } = event;

      let request = _classPrivateFieldGet(this, _requests).get(requestId);
      /* istanbul ignore next: race condition paranioa */


      if (!request) return;

      if (this._intercept) {
        request.error = errorText;
        await this.onrequestfailed(request);
      }

      _classPrivateFieldGet(this, _requests).delete(requestId);

      _classPrivateFieldGet(this, _authentications).delete(request.interceptId);
    });

    this.page = page;
    this.page.on('Fetch.authRequired', this._handleAuthRequired);
    this.page.on('Fetch.requestPaused', this._handleRequestPaused);
    this.page.on('Network.requestWillBeSent', this._handleRequestWillBeSent);
    this.page.on('Network.responseReceived', this._handleResponseReceived);
    this.page.on('Network.eventSourceMessageReceived', this._handleEventSourceMessageReceived);
    this.page.on('Network.loadingFinished', this._handleLoadingFinished);
    this.page.on('Network.loadingFailed', this._handleLoadingFailed);
    /* istanbul ignore next: race condition */

    this.page.send('Network.enable').catch(e => this.log.debug(e, this.page.meta));
  } // Enable request interception


  async intercept(options) {
    this._intercept = true;
    this.onrequest = (0, _discovery.createRequestHandler)(options, this.page.meta);
    this.onrequestfinished = (0, _discovery.createRequestFinishedHandler)(options, this.page.meta);
    this.onrequestfailed = (0, _discovery.createRequestFailedHandler)(options, this.page.meta);
    await this.page.send('Fetch.enable', {
      handleAuthRequests: true,
      patterns: [{
        urlPattern: '*'
      }]
    });
  } // Resolves after the timeout when there are no more in-flight requests.


  async idle(filter = r => r, timeout = this.timeout || 100) {
    this.log.debug(`Wait for ${timeout}ms idle`, this.page.meta);
    await (0, _utils.waitFor)(() => {
      if (this.page.closedReason) {
        throw new Error(`Network error: ${this.page.closedReason}`);
      }

      return Array.from(_classPrivateFieldGet(this, _requests).values()).filter(filter).length === 0;
    }, {
      timeout: 30 * 1000,
      // 30 second error timeout
      idle: timeout
    });
  } // Called when a request requires authentication. Responds to the auth request with any
  // provided authorization credentials.


}

exports.default = Network;