"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _client = _interopRequireDefault(require("@percy/client"));

var _config = _interopRequireDefault(require("@percy/config"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _queue = _interopRequireDefault(require("./queue"));

var _browser = _interopRequireDefault(require("./browser"));

var _server = _interopRequireDefault(require("./server"));

var _config2 = require("./config");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _cache = new WeakMap();

var _uploads = new WeakMap();

var _snapshots = new WeakMap();

// A Percy instance will create a new build when started, handle snapshot
// creation, asset discovery, and resource uploads, and will finalize the build
// when stopped. Snapshots are processed concurrently and the build is not
// finalized until all snapshots have been handled.
class Percy {
  // Static shortcut to create and start an instance in one call
  static async start(options) {
    let instance = new this(options);
    await instance.start();
    return instance;
  }

  constructor({
    // initial log level
    loglevel,
    // upload snapshots eagerly by default
    deferUploads = false,
    // configuration filepath
    config,
    // provided to @percy/client
    token,
    clientInfo = '',
    environmentInfo = '',
    // snapshot server options
    server = true,
    port = 5338,
    // options such as `snapshot` and `discovery` that are valid Percy config
    // options which will become accessible via the `.config` property
    ...options
  } = {}) {
    _defineProperty(this, "log", (0, _logger.default)('core'));

    _defineProperty(this, "readyState", null);

    _cache.set(this, {
      writable: true,
      value: new Map()
    });

    _uploads.set(this, {
      writable: true,
      value: new _queue.default()
    });

    _snapshots.set(this, {
      writable: true,
      value: new _queue.default()
    });

    if (loglevel) this.loglevel(loglevel);
    this.deferUploads = deferUploads;
    this.config = config === false ? _config.default.getDefaults(options) : _config.default.load({
      path: config,
      overrides: options
    });
    let {
      concurrency
    } = this.config.discovery;
    if (concurrency) _classPrivateFieldGet(this, _snapshots).concurrency = concurrency;
    if (this.deferUploads) _classPrivateFieldGet(this, _uploads).stop();
    this.client = new _client.default({
      token,
      clientInfo,
      environmentInfo
    });
    this.browser = new _browser.default({ ...this.config.discovery.launchOptions,
      cookies: this.config.discovery.cookies
    });

    if (server) {
      this.server = (0, _server.default)(this);
      this.port = port;
    }
  } // Shortcut for controlling the global logger's log level.


  loglevel(level) {
    return _logger.default.loglevel(level);
  } // Snapshot server API address


  address() {
    return `http://localhost:${this.port}`;
  } // Resolves once snapshot and upload queues are idle


  async idle() {
    await _classPrivateFieldGet(this, _snapshots).idle();
    await _classPrivateFieldGet(this, _uploads).idle();
  } // Waits for snapshot idle and flushes the upload queue


  async dispatch() {
    await _classPrivateFieldGet(this, _snapshots).idle();
    await _classPrivateFieldGet(this, _uploads).flush();
  } // Immediately stops all queues, preventing any more tasks from running


  close() {
    _classPrivateFieldGet(this, _snapshots).close(true);

    _classPrivateFieldGet(this, _uploads).close(true);
  } // Starts a local API server, a browser process, and queues creating a new Percy build which will run
  // at a later time when uploads are deferred, or run immediately when not deferred.


  async start() {
    // throws when the token is missing
    this.client.getToken(); // already starting or started

    if (this.readyState != null) return;
    this.readyState = 0;

    try {
      var _this$server;

      // create a percy build as the first immediately queued task
      let buildTask = _classPrivateFieldGet(this, _uploads).push('build/create', () => {
        // pause other queued tasks until after the build is created
        _classPrivateFieldGet(this, _uploads).stop();

        return this.client.createBuild().then(({
          data: {
            id,
            attributes
          }
        }) => {
          this.build = {
            id
          };
          this.build.number = attributes['build-number'];
          this.build.url = attributes['web-url'];

          _classPrivateFieldGet(this, _uploads).run();
        });
      }, 0);

      if (!this.deferUploads) {
        // when not deferred, wait until the build is created
        await buildTask;
      } else {
        // handle deferred build errors
        buildTask.catch(err => {
          this.log.error('Failed to create build');
          this.log.error(err);
          this.close();
        });
      } // launch the discovery browser


      await this.browser.launch(this.config.discovery.launchOptions); // if there is a server, start listening

      await ((_this$server = this.server) === null || _this$server === void 0 ? void 0 : _this$server.listen(this.port)); // mark this process as running

      this.log.info('Percy has started!');
      this.readyState = 1;
    } catch (error) {
      var _this$server2;

      // on error, close any running server and browser
      await ((_this$server2 = this.server) === null || _this$server2 === void 0 ? void 0 : _this$server2.close());
      await this.browser.close();
      this.readyState = 3; // throw an easier-to-understand error when the port is taken

      if (error.code === 'EADDRINUSE') {
        throw new Error('Percy is already running or the port is in use');
      } else {
        throw error;
      }
    }
  } // Stops the local API server and browser once snapshots have completed and finalizes the Percy
  // build. Does nothing if not running. When `force` is true, any queued tasks are cleared.


  async stop(force) {
    var _this$server3, _this$build;

    // not started or already stopped
    if (!this.readyState || this.readyState > 2) return; // close queues asap

    if (force) this.close(); // already stopping

    if (this.readyState === 2) return;
    this.readyState = 2; // log when force stopping

    let meta = {
      build: this.build
    };
    if (force) this.log.info('Stopping percy...', meta); // close the snapshot queue and wait for it to empty

    if (_classPrivateFieldGet(this, _snapshots).close().length) {
      await _classPrivateFieldGet(this, _snapshots).empty(len => {
        this.log.progress(`Processing ${len}` + ` snapshot${len !== 1 ? 's' : ''}...`, !!len);
      });
    } // run, close, and wait for the upload queue to empty


    if (_classPrivateFieldGet(this, _uploads).run().close().length) {
      await _classPrivateFieldGet(this, _uploads).empty(len => {
        this.log.progress(`Uploading ${len}` + ` snapshot${len !== 1 ? 's' : ''}...`, !!len);
      });
    } // close the any running server and browser


    await ((_this$server3 = this.server) === null || _this$server3 === void 0 ? void 0 : _this$server3.close());
    await this.browser.close();

    if ((_this$build = this.build) !== null && _this$build !== void 0 && _this$build.failed) {
      // do not finalize failed builds
      this.log.warn(`Build #${this.build.number} failed: ${this.build.url}`, meta);
    } else if (this.build) {
      // finalize the build
      await this.client.finalizeBuild(this.build.id);
      this.log.info(`Finalized build #${this.build.number}: ${this.build.url}`, meta);
    } else {
      // no build was ever created (likely failed while deferred)
      this.log.warn('Build not created', meta);
    }

    this.readyState = 3;
  } // Deprecated capture method


  capture(options) {
    this.log.deprecated('The #capture() method will be ' + 'removed in 1.0.0. Use #snapshot() instead.');
    return this.snapshot(options);
  } // Takes one or more snapshots of a page while discovering resources to upload with the
  // snapshot. If an existing dom snapshot is provided, it will be served as the root resource
  // during asset discovery. Once asset discovery has completed, the queued snapshot will resolve
  // and an upload task will be queued separately.


  snapshot(options) {
    if (this.readyState !== 1) {
      throw new Error('Not running');
    }

    let {
      url,
      name,
      discovery,
      domSnapshot,
      execute,
      waitForTimeout,
      waitForSelector,
      additionalSnapshots,
      ...conf
    } = (0, _config2.getSnapshotConfig)(options, this.config, this.log);
    let meta = {
      snapshot: {
        name
      },
      build: this.build
    };

    let maybeDebug = (val, msg) => {
      if (val != null) this.log.debug(msg(val), meta);
    }; // clear any existing pending upload for the same snapshot (for retries)


    _classPrivateFieldGet(this, _uploads).clear(`upload/${name}`); // resolves after asset discovery has finished and the upload has been queued


    return _classPrivateFieldGet(this, _snapshots).push(`snapshot/${name}`, async () => {
      let resources = new Map();
      let root, page;

      try {
        var _options$discovery, _options$discovery2, _options$discovery3, _options$discovery4, _options$discovery5;

        this.log.debug('---------');
        this.log.debug('Handling snapshot:', meta);
        this.log.debug(`-> name: ${name}`, meta);
        this.log.debug(`-> url: ${url}`, meta);
        maybeDebug(conf.widths, v => `-> widths: ${v.join('px, ')}px`);
        maybeDebug(conf.minHeight, v => `-> minHeight: ${v}px`);
        maybeDebug(conf.enableJavaScript, v => `-> enableJavaScript: ${v}`);
        maybeDebug((_options$discovery = options.discovery) === null || _options$discovery === void 0 ? void 0 : _options$discovery.allowedHostnames, v => `-> discovery.allowedHostnames: ${v}`);
        maybeDebug((_options$discovery2 = options.discovery) === null || _options$discovery2 === void 0 ? void 0 : _options$discovery2.requestHeaders, v => `-> discovery.requestHeaders: ${JSON.stringify(v)}`);
        maybeDebug((_options$discovery3 = options.discovery) === null || _options$discovery3 === void 0 ? void 0 : _options$discovery3.authorization, v => `-> discovery.authorization: ${JSON.stringify(v)}`);
        maybeDebug((_options$discovery4 = options.discovery) === null || _options$discovery4 === void 0 ? void 0 : _options$discovery4.disableCache, v => `-> discovery.disableCache: ${v}`);
        maybeDebug((_options$discovery5 = options.discovery) === null || _options$discovery5 === void 0 ? void 0 : _options$discovery5.userAgent, v => `-> discovery.userAgent: ${v}`);
        maybeDebug(options.waitForTimeout, v => `-> waitForTimeout: ${v}`);
        maybeDebug(options.waitForSelector, v => `-> waitForSelector: ${v}`);
        maybeDebug(options.execute, v => `-> execute: ${v}`);
        maybeDebug(conf.clientInfo, v => `-> clientInfo: ${v}`);
        maybeDebug(conf.environmentInfo, v => `-> environmentInfo: ${v}`); // create the root resource if a dom snapshot was provided

        if (domSnapshot) {
          root = (0, _utils.createRootResource)(url, domSnapshot);
        } // copy widths to prevent mutation later


        let widths = conf.widths.slice(); // open a new browser page

        page = await this.browser.page({
          networkIdleTimeout: this.config.discovery.networkIdleTimeout,
          enableJavaScript: domSnapshot ? conf.enableJavaScript : true,
          requestHeaders: discovery.requestHeaders,
          authorization: discovery.authorization,
          userAgent: discovery.userAgent,
          meta,
          // initial width
          width: widths.shift(),
          // enable network inteception
          intercept: {
            disableCache: discovery.disableCache,
            allowedHostnames: discovery.allowedHostnames,
            getResource: url => {
              var _root;

              return url === ((_root = root) === null || _root === void 0 ? void 0 : _root.url) ? root : resources.get(url) || _classPrivateFieldGet(this, _cache).get(url);
            },
            addResource: resource => {
              if (resource.root) return;
              resources.set(resource.url, resource);

              _classPrivateFieldGet(this, _cache).set(resource.url, resource);
            }
          }
        }); // navigate to the url and trigger resize events

        await page.goto(url);

        for (let width of widths) await page.resize({
          width
        }); // create and add a percy-css resource


        let percyCSS = (0, _utils.createPercyCSSResource)(url, conf.percyCSS);
        if (percyCSS) resources.set(percyCSS.url, percyCSS);

        if (root) {
          // ensure asset discovery has finished before uploading
          await page.network.idle(({
            url
          }) => (0, _utils.hostnameMatches)(discovery.allowedHostnames, url));
          root = (0, _utils.injectPercyCSS)(root, percyCSS);
          this.log.info(`Snapshot taken: ${name}`, meta);

          this._scheduleUpload(name, conf, [root, ...resources.values()]);
        } else {
          // capture additional snapshots sequentially
          let snapshot = {
            name,
            waitForTimeout,
            waitForSelector,
            execute
          };

          for (let {
            name,
            ...opts
          } of [snapshot, ...additionalSnapshots]) {
            this.log.debug(`Taking snapshot: ${name}`, meta); // will wait for timeouts, selectors, and additional network activity

            let {
              url,
              dom
            } = await page.snapshot({ ...conf,
              ...opts
            });
            let root = (0, _utils.injectPercyCSS)((0, _utils.createRootResource)(url, dom), percyCSS);
            resources.delete(root.url); // remove any discovered root resource

            this.log.info(`Snapshot taken: ${name}`, meta);

            this._scheduleUpload(name, conf, [root, ...resources.values()]);
          }
        }
      } catch (error) {
        this.log.error(`Encountered an error taking snapshot: ${name}`, meta);
        this.log.error(error, meta);
      } finally {
        var _page;

        await ((_page = page) === null || _page === void 0 ? void 0 : _page.close());
      }
    });
  } // Queues a snapshot upload with the provided configuration options and resources


  _scheduleUpload(name, conf, resources) {
    _classPrivateFieldGet(this, _uploads).push(`upload/${name}`, async () => {
      try {
        // attach a log resource for debugging
        resources = resources.concat((0, _utils.createLogResource)(_logger.default.query(l => {
          var _l$meta$snapshot;

          return ((_l$meta$snapshot = l.meta.snapshot) === null || _l$meta$snapshot === void 0 ? void 0 : _l$meta$snapshot.name) === name;
        })));
        await this.client.sendSnapshot(this.build.id, { ...conf,
          name,
          resources
        });
      } catch (error) {
        var _error$response, _failed$detail;

        let meta = {
          snapshot: {
            name
          },
          build: this.build
        };
        let failed = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 422 && error.response.body.errors.find(e => {
          var _e$source;

          return ((_e$source = e.source) === null || _e$source === void 0 ? void 0 : _e$source.pointer) === '/data/attributes/build';
        });
        this.log.error(`Encountered an error uploading snapshot: ${name}`, meta);
        this.log.error((_failed$detail = failed === null || failed === void 0 ? void 0 : failed.detail) !== null && _failed$detail !== void 0 ? _failed$detail : error, meta); // build failed at some point, stop accepting snapshots

        if (failed) {
          this.build.failed = true;
          this.close();
        }
      }
    });
  }

}

exports.default = Percy;