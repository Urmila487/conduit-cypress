"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRequestHandler = createRequestHandler;
exports.createRequestFinishedHandler = createRequestFinishedHandler;
exports.createRequestFailedHandler = createRequestFailedHandler;

var _logger = _interopRequireDefault(require("@percy/logger"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MAX_RESOURCE_SIZE = 15 * 1024 ** 2; // 15MB

const ALLOWED_STATUSES = [200, 201, 301, 302, 304, 307, 308];

function createRequestHandler({
  disableCache,
  getResource
}, m) {
  let log = (0, _logger.default)('core:discovery');
  return async request => {
    let url = request.url;
    let meta = { ...m,
      url
    };

    try {
      log.debug(`Handling request: ${url}`, meta);
      let resource = getResource(url);

      if (resource !== null && resource !== void 0 && resource.root) {
        log.debug('-> Serving root resource', meta);
        await request.respond(resource);
      } else if (resource && !disableCache) {
        log.debug('-> Resource cache hit', meta);
        await request.respond(resource);
      } else {
        await request.continue();
      }
    } catch (error) {
      log.debug(`Encountered an error handling request: ${url}`, meta);
      log.debug(error);
      /* istanbul ignore next: race condition */

      await request.abort(error).catch(e => log.debug(e, meta));
    }
  };
}

function createRequestFinishedHandler({
  allowedHostnames,
  disableCache,
  getResource,
  addResource
}, m) {
  let log = (0, _logger.default)('core:discovery');
  return async request => {
    let origin = request.redirectChain[0] || request;
    let url = (0, _utils.normalizeURL)(origin.url);
    let meta = { ...m,
      url
    };

    try {
      var _resource;

      let resource = getResource(url); // process and cache the response and resource

      if (!((_resource = resource) !== null && _resource !== void 0 && _resource.root) && (!resource || disableCache)) {
        let response = request.response;
        let capture = response && (0, _utils.hostnameMatches)(allowedHostnames, url);
        let body = capture && (await response.buffer());
        log.debug(`Processing resource: ${url}`, meta);
        /* istanbul ignore next: sanity check */

        if (!response) {
          return log.debug('-> Skipping no response', meta);
        } else if (!capture) {
          return log.debug('-> Skipping remote resource', meta);
        } else if (!body.length) {
          return log.debug('-> Skipping empty response', meta);
        } else if (body.length > MAX_RESOURCE_SIZE) {
          return log.debug('-> Skipping resource larger than 15MB', meta);
        } else if (!ALLOWED_STATUSES.includes(response.status)) {
          return log.debug(`-> Skipping disallowed status [${response.status}]`, meta);
        }

        resource = (0, _utils.createResource)(url, body, response.mimeType, {
          status: response.status,
          // 'Network.responseReceived' returns headers split by newlines, however
          // `Fetch.fulfillRequest` (used for cached responses) will hang with newlines.
          headers: Object.entries(response.headers).reduce((norm, [key, value]) => Object.assign(norm, {
            [key]: value.split('\n')
          }), {})
        });
        log.debug(`-> sha: ${resource.sha}`, meta);
        log.debug(`-> mimetype: ${resource.mimetype}`, meta);
      }

      addResource(resource);
    } catch (error) {
      log.debug(`Encountered an error processing resource: ${url}`, meta);
      log.debug(error);
    }
  };
}

function createRequestFailedHandler(options, meta) {
  let log = (0, _logger.default)('core:discovery');
  return ({
    url,
    error
  }) => {
    // do not log generic failures since the real error was most likely
    // already logged from elsewhere
    if (error !== 'net::ERR_FAILED') {
      log.debug(`Request failed for ${url}: ${error}`, { ...meta,
        url
      });
    }
  };
}