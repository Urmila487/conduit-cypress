"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _crossSpawn = _interopRequireDefault(require("cross-spawn"));

var _events = _interopRequireDefault(require("events"));

var _ws = _interopRequireDefault(require("ws"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _install = _interopRequireDefault(require("./install"));

var _page = _interopRequireDefault(require("./page"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _callbacks = new WeakMap();

var _lastid = new WeakMap();

class Browser extends _events.default {
  constructor({
    executable = process.env.PERCY_BROWSER_EXECUTABLE,
    headless = true,
    cookies = [],
    args = [],
    timeout
  }) {
    super();

    _defineProperty(this, "log", (0, _logger.default)('core:browser'));

    _defineProperty(this, "pages", new Map());

    _defineProperty(this, "closed", false);

    _callbacks.set(this, {
      writable: true,
      value: new Map()
    });

    _lastid.set(this, {
      writable: true,
      value: 0
    });

    _defineProperty(this, "defaultArgs", ['--enable-features=NetworkService,NetworkServiceInProcess', '--disable-background-networking', '--disable-background-timer-throttling', '--disable-backgrounding-occluded-windows', '--disable-breakpad', '--disable-client-side-phishing-detection', '--disable-component-extensions-with-background-pages', '--disable-default-apps', '--disable-dev-shm-usage', '--disable-extensions', '--disable-features=TranslateUI', '--disable-hang-monitor', '--disable-ipc-flooding-protection', '--disable-popup-blocking', '--disable-prompt-on-repost', '--disable-renderer-backgrounding', '--disable-sync', '--disable-web-security', '--force-color-profile=srgb', '--metrics-recording-only', '--no-first-run', '--no-sandbox', '--enable-automation', '--password-store=basic', '--use-mock-keychain', '--remote-debugging-port=0']);

    this.launchTimeout = timeout;
    this.executable = executable;
    this.headless = headless;
    this.args = args; // transform cookies object to an array of cookie params

    this.cookies = Array.isArray(cookies) ? cookies : Object.entries(cookies).map(([name, value]) => ({
      name,
      value
    }));
  }

  async launch() {
    if (this.isConnected()) return; // check if any provided executable exists

    if (this.executable && !(0, _fs.existsSync)(this.executable)) {
      this.log.error(`Browser executable not found: ${this.executable}`);
      this.executable = null;
    } // download and install the browser if not already present


    this.executable || (this.executable = await _install.default.chromium()); // create a temporary profile directory

    this.profile = await _fs.promises.mkdtemp(_path.default.join(_os.default.tmpdir(), 'percy-browser-')); // collect args to pass to the browser process

    let args = [...this.defaultArgs, `--user-data-dir=${this.profile}`];
    /* istanbul ignore next: only false for debugging */

    if (this.headless) args.push('--headless', '--hide-scrollbars', '--mute-audio');

    for (let a of this.args) if (!args.includes(a)) args.push(a); // spawn the browser process detached in its own group and session


    this.process = (0, _crossSpawn.default)(this.executable, args, {
      detached: process.platform !== 'win32'
    }); // connect a websocket to the devtools address

    let addr = await this.address(this.launchTimeout);
    this.ws = new _ws.default(addr, {
      perMessageDeflate: false
    }); // wait until the websocket has connected before continuing

    await new Promise(resolve => this.ws.once('open', resolve));
    this.ws.on('message', data => this._handleMessage(data)); // close any initial pages that automatically opened

    await this.send('Target.getTargets').then(({
      targetInfos
    }) => {
      /* istanbul ignore next: this doesn't happen in every environment */
      return Promise.all(targetInfos.reduce((promises, target) => {
        return target.type !== 'page' ? promises : promises.concat(this.send('Target.closeTarget', {
          targetId: target.targetId
        }));
      }, []));
    });
  }

  isConnected() {
    var _this$ws;

    return ((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === _ws.default.OPEN;
  }

  async close() {
    if (this.closed) return;
    this.closed = true; // reject any pending callbacks

    for (let callback of _classPrivateFieldGet(this, _callbacks).values()) {
      callback.reject(Object.assign(callback.error, {
        message: `Protocol error (${callback.method}): Browser closed.`
      }));
    } // trigger rejecting pending page callbacks


    for (let page of this.pages.values()) {
      page._handleClose();
    } // clear callback and page references


    _classPrivateFieldGet(this, _callbacks).clear();

    this.pages.clear(); // resolves when the browser has closed

    let closed = new Promise(resolve => {
      /* istanbul ignore next: race condition paranoia */
      if (!this.process || this.process.exitCode) resolve();else this.process.on('exit', resolve);
    }); // force close if needed and able to

    let kill = () => {
      var _this$process;

      /* istanbul ignore next:
       *   difficult to test failure here without mocking private properties */
      if ((_this$process = this.process) !== null && _this$process !== void 0 && _this$process.pid && !this.process.killed) {
        try {
          this.process.kill('SIGKILL');
        } catch (error) {
          throw new Error(`Unable to close the browser: ${error.stack}`);
        }
      }
    };
    /* istanbul ignore else:
     *   difficult to test failure here without mocking private properties */


    if (this.profile) kill();else this.send('Browser.close').catch(() => kill()); // after closing, attempt to clean up the profile directory

    await closed.then(() => new Promise(resolve => {
      var _this$process2, _this$process3, _this$process4;

      // needed due to a bug in Node 12 - https://github.com/nodejs/node/issues/27097
      (_this$process2 = this.process) === null || _this$process2 === void 0 ? void 0 : _this$process2.stdin.end();
      (_this$process3 = this.process) === null || _this$process3 === void 0 ? void 0 : _this$process3.stdout.end();
      (_this$process4 = this.process) === null || _this$process4 === void 0 ? void 0 : _this$process4.stderr.end();
      /* istanbul ignore else: sanity */

      if (this.profile) {
        (0, _rimraf.default)(this.profile, error => {
          /* istanbul ignore next:
           *   this might happen on some systems but ultimately it is a temp file */
          if (error) {
            this.log.debug('Could not clean up temporary browser profile directory.');
            this.log.debug(error);
          }

          resolve();
        });
      } else {
        resolve();
      }
    }));
  }

  async page(options) {
    // create and attach to a new page target returning the resulting page instance
    let {
      targetId
    } = await this.send('Target.createTarget', {
      url: 'about:blank'
    });
    let {
      sessionId
    } = await this.send('Target.attachToTarget', {
      targetId,
      flatten: true
    });
    return this.pages.get(sessionId).init(options);
  }

  async send(method, params) {
    /* istanbul ignore next:
     *   difficult to test failure here without mocking private properties */
    if (!this.isConnected()) throw new Error('Browser not connected'); // every command needs a unique id

    let id = _classPrivateFieldSet(this, _lastid, +_classPrivateFieldGet(this, _lastid) + 1);

    if (!params && typeof method === 'object') {
      // allow providing a raw message as the only argument and return the id
      this.ws.send(JSON.stringify({ ...method,
        id
      }));
      return id;
    } else {
      // send the message and return a promise that resolves or rejects for a matching response
      this.ws.send(JSON.stringify({
        id,
        method,
        params
      }));
      return new Promise((resolve, reject) => {
        _classPrivateFieldGet(this, _callbacks).set(id, {
          error: new Error(),
          resolve,
          reject,
          method
        });
      });
    }
  } // Returns the devtools websocket address. If not already known, will watch the browser's
  // stderr and resolves when it emits the devtools protocol address or rejects if the process
  // exits for any reason or if the address does not appear after the timeout.


  async address(timeout = 30000) {
    this._address || (this._address = await new Promise((resolve, reject) => {
      let stderr = '';

      let handleData = chunk => {
        stderr += chunk = chunk.toString();
        let match = chunk.match(/^DevTools listening on (ws:\/\/.*)$/m);
        if (match) cleanup(() => resolve(match[1]));
      };
      /* istanbul ignore next: for sanity */


      let handleExit = () => handleError();

      let handleClose = () => handleError();

      let handleError = error => {
        cleanup(() => {
          var _error$message;

          return reject(new Error(`Failed to launch browser. ${(_error$message = error === null || error === void 0 ? void 0 : error.message) !== null && _error$message !== void 0 ? _error$message : ''}\n${stderr}'\n\n`));
        });
      };

      let cleanup = callback => {
        clearTimeout(timeoutId);
        this.process.stderr.off('data', handleData);
        this.process.stderr.off('close', handleClose);
        this.process.off('exit', handleExit);
        this.process.off('error', handleError);
        callback();
      };

      let timeoutId = setTimeout(() => handleError(new Error(`Timed out after ${timeout}ms`)), timeout);
      this.process.stderr.on('data', handleData);
      this.process.stderr.on('close', handleClose);
      this.process.on('exit', handleExit);
      this.process.on('error', handleError);
    }));
    return this._address;
  }

  _handleMessage(data) {
    data = JSON.parse(data);

    if (data.method === 'Target.attachedToTarget') {
      // create a new page reference when attached to a target
      this.pages.set(data.params.sessionId, new _page.default(this, data));
    } else if (data.method === 'Target.detachedFromTarget') {
      // remove the old page reference when detached from a target
      let page = this.pages.get(data.params.sessionId);
      this.pages.delete(data.params.sessionId);
      page === null || page === void 0 ? void 0 : page._handleClose();
    }

    if (data.sessionId) {
      // message was for a specific page that sent it
      let page = this.pages.get(data.sessionId);
      page === null || page === void 0 ? void 0 : page._handleMessage(data);
    } else if (data.id && _classPrivateFieldGet(this, _callbacks).has(data.id)) {
      // resolve or reject a pending promise created with #send()
      let callback = _classPrivateFieldGet(this, _callbacks).get(data.id);

      _classPrivateFieldGet(this, _callbacks).delete(data.id);
      /* istanbul ignore next:
       *   currently does not happen during asset discovery but it's here just in case */


      if (data.error) {
        callback.reject(Object.assign(callback.error, {
          message: `Protocol error (${callback.method}): ${data.error.message}` + ('data' in data.error ? `: ${data.error.data}` : '')
        }));
      } else {
        callback.resolve(data.result);
      }
    } else {
      // emit the message as an event
      this.emit(data.method, data.params);
    }
  }

}

exports.default = Browser;