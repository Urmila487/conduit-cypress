"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Snapshot = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _cliCommand = _interopRequireWildcard(require("@percy/cli-command"));

var _core = _interopRequireDefault(require("@percy/core"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _globby = _interopRequireDefault(require("globby"));

var _yaml = _interopRequireDefault(require("yaml"));

var _config = require("../config");

var _package = _interopRequireDefault(require("../../package.json"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Throw a better error message for invalid urls
function validURL(input, base) {
  try {
    return new URL(input, base || undefined);
  } catch (error) {
    throw new Error(`Invalid URL: ${error.input}`);
  }
}

class Snapshot extends _cliCommand.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "log", (0, _logger.default)('cli:snapshot'));
  }

  async run() {
    if (!this.isPercyEnabled()) {
      return this.log.info('Percy is disabled. Skipping snapshots');
    }

    let {
      pathname
    } = this.args;

    if (!_fs.default.existsSync(pathname)) {
      this.error(`Not found: ${pathname}`);
    }

    let {
      'base-url': baseUrl,
      'dry-run': dry
    } = this.flags;

    let isStatic = _fs.default.lstatSync(pathname).isDirectory();

    if (baseUrl) {
      if (isStatic && !baseUrl.startsWith('/')) {
        this.error('The base-url must begin with a forward slash (/) ' + 'when snapshotting static directories');
      } else if (!isStatic && !baseUrl.startsWith('http')) {
        this.error('The base-url must include a protocol and hostname ' + 'when snapshotting a list of pages');
      }
    }

    this.percy = new _core.default({ ...this.percyrc({
        static: isStatic ? {
          baseUrl
        } : null
      }),
      clientInfo: `${_package.default.name}/${_package.default.version}`,
      server: false
    });
    let pages = isStatic ? await this.loadStaticPages(pathname) : await this.loadPagesFile(pathname);
    pages = pages.map(page => {
      var _page;

      // allow a list of urls
      if (typeof page === 'string') page = {
        url: page
      }; // validate and prepend the baseUrl

      let uri = validURL(page.url, !isStatic && baseUrl);
      page.url = uri.href; // default page name to url /pathname?search#hash

      (_page = page).name || (_page.name = `${uri.pathname}${uri.search}${uri.hash}`);
      return page;
    });
    let l = pages.length;
    if (!l) this.error('No snapshots found');
    if (!dry) await this.percy.start();else this.log.info(`Found ${l} snapshot${l === 1 ? '' : 's'}`);

    for (let page of pages) {
      if (dry) {
        this.log.info(`Snapshot found: ${page.name}`);
        this.log.debug(`-> url: ${page.url}`);

        for (let s of page.additionalSnapshots || []) {
          let name = s.name || `${s.prefix || ''}${page.name}${s.suffix || ''}`;
          this.log.info(`Snapshot found: ${name}`);
          this.log.debug(`-> url: ${page.url}`);
        }
      } else {
        this.percy.snapshot(page);
      }
    }
  } // Called on error, interupt, or after running


  async finally(error) {
    var _this$percy;

    await ((_this$percy = this.percy) === null || _this$percy === void 0 ? void 0 : _this$percy.stop(!!error));

    if (this.server) {
      await new Promise(resolve => {
        this.server.close(resolve);
      });
    }
  } // Serves a static directory at a base-url and resolves when listening.


  async serve(staticDir, baseUrl) {
    let http = require('http');

    let serve = require('serve-handler');

    return new Promise(resolve => {
      this.server = http.createServer((req, res) => {
        serve(req, res, {
          public: staticDir
        });
      }).listen(() => {
        let {
          port
        } = this.server.address();
        resolve(`http://localhost:${port}`);
      });
    });
  } // Starts a static server and returns a list of pages to snapshot.


  async loadStaticPages(pathname) {
    let {
      baseUrl,
      files,
      ignore
    } = this.percy.config.static;
    let paths = await (0, _globby.default)(files, {
      ignore: [].concat(ignore).filter(Boolean),
      cwd: pathname
    });
    let addr = !this.flags['dry-run'] ? await this.serve(pathname, baseUrl) : 'http://localhost';
    return paths.sort().map(path => `${addr}${baseUrl}${path}`);
  } // Loads pages to snapshot from a js, json, or yaml file.


  async loadPagesFile(pathname) {
    let ext = _path.default.extname(pathname);

    if (ext === '.js') {
      let pages = require(_path.default.resolve(pathname));

      return typeof pages === 'function' ? await pages() : pages;
    } else if (ext === '.json') {
      return JSON.parse(_fs.default.readFileSync(pathname, {
        encoding: 'utf-8'
      }));
    } else if (ext.match(/\.ya?ml$/)) {
      return _yaml.default.parse(_fs.default.readFileSync(pathname, {
        encoding: 'utf-8'
      }));
    } else {
      return this.error(`Unsupported filetype: ${pathname}`);
    }
  }

}

exports.Snapshot = Snapshot;

_defineProperty(Snapshot, "description", 'Snapshot a list of pages from a file or directory');

_defineProperty(Snapshot, "args", [{
  name: 'pathname',
  description: 'path to a directory or file containing a list of pages',
  required: true
}]);

_defineProperty(Snapshot, "flags", { ..._cliCommand.flags.logging,
  ..._cliCommand.flags.discovery,
  ..._cliCommand.flags.config,
  'base-url': _cliCommand.flags.string({
    description: 'the base url pages are hosted at when snapshotting',
    char: 'b'
  }),
  'dry-run': _cliCommand.flags.boolean({
    description: 'prints a list of pages to snapshot without snapshotting',
    char: 'd'
  }),
  // static only flags
  files: _cliCommand.flags.string({
    description: 'one or more globs matching static file paths to snapshot',
    default: _config.schema.static.properties.files.default,
    percyrc: 'static.files',
    multiple: true
  }),
  ignore: _cliCommand.flags.string({
    description: 'one or more globs matching static file paths to ignore',
    default: _config.schema.static.properties.ignore.default,
    percyrc: 'static.ignore',
    multiple: true
  })
});

_defineProperty(Snapshot, "examples", ['$ percy snapshot ./public', '$ percy snapshot pages.yml']);